{"ast":null,"code":"'use strict';\n\nconst {\n  Writable\n} = require('stream');\nconst {\n  getDecoder\n} = require('../utils.js');\nclass URLEncoded extends Writable {\n  constructor(cfg) {\n    const streamOpts = {\n      autoDestroy: true,\n      emitClose: true,\n      highWaterMark: typeof cfg.highWaterMark === 'number' ? cfg.highWaterMark : undefined\n    };\n    super(streamOpts);\n    let charset = cfg.defCharset || 'utf8';\n    if (cfg.conType.params && typeof cfg.conType.params.charset === 'string') charset = cfg.conType.params.charset;\n    this.charset = charset;\n    const limits = cfg.limits;\n    this.fieldSizeLimit = limits && typeof limits.fieldSize === 'number' ? limits.fieldSize : 1 * 1024 * 1024;\n    this.fieldsLimit = limits && typeof limits.fields === 'number' ? limits.fields : Infinity;\n    this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === 'number' ? limits.fieldNameSize : 100;\n    this._inKey = true;\n    this._keyTrunc = false;\n    this._valTrunc = false;\n    this._bytesKey = 0;\n    this._bytesVal = 0;\n    this._fields = 0;\n    this._key = '';\n    this._val = '';\n    this._byte = -2;\n    this._lastPos = 0;\n    this._encode = 0;\n    this._decoder = getDecoder(charset);\n  }\n  static detect(conType) {\n    return conType.type === 'application' && conType.subtype === 'x-www-form-urlencoded';\n  }\n  _write(chunk, enc, cb) {\n    if (this._fields >= this.fieldsLimit) return cb();\n    let i = 0;\n    const len = chunk.length;\n    this._lastPos = 0;\n\n    // Check if we last ended mid-percent-encoded byte\n    if (this._byte !== -2) {\n      i = readPctEnc(this, chunk, i, len);\n      if (i === -1) return cb(new Error('Malformed urlencoded form'));\n      if (i >= len) return cb();\n      if (this._inKey) ++this._bytesKey;else ++this._bytesVal;\n    }\n    main: while (i < len) {\n      if (this._inKey) {\n        // Parsing key\n\n        i = skipKeyBytes(this, chunk, i, len);\n        while (i < len) {\n          switch (chunk[i]) {\n            case 61:\n              // '='\n              if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = ++i;\n              this._key = this._decoder(this._key, this._encode);\n              this._encode = 0;\n              this._inKey = false;\n              continue main;\n            case 38:\n              // '&'\n              if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = ++i;\n              this._key = this._decoder(this._key, this._encode);\n              this._encode = 0;\n              if (this._bytesKey > 0) {\n                this.emit('field', this._key, '', {\n                  nameTruncated: this._keyTrunc,\n                  valueTruncated: false,\n                  encoding: this.charset,\n                  mimeType: 'text/plain'\n                });\n              }\n              this._key = '';\n              this._val = '';\n              this._keyTrunc = false;\n              this._valTrunc = false;\n              this._bytesKey = 0;\n              this._bytesVal = 0;\n              if (++this._fields >= this.fieldsLimit) {\n                this.emit('fieldsLimit');\n                return cb();\n              }\n              continue;\n            case 43:\n              // '+'\n              if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n              this._key += ' ';\n              this._lastPos = i + 1;\n              break;\n            case 37:\n              // '%'\n              if (this._encode === 0) this._encode = 1;\n              if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = i + 1;\n              this._byte = -1;\n              i = readPctEnc(this, chunk, i + 1, len);\n              if (i === -1) return cb(new Error('Malformed urlencoded form'));\n              if (i >= len) return cb();\n              ++this._bytesKey;\n              i = skipKeyBytes(this, chunk, i, len);\n              continue;\n          }\n          ++i;\n          ++this._bytesKey;\n          i = skipKeyBytes(this, chunk, i, len);\n        }\n        if (this._lastPos < i) this._key += chunk.latin1Slice(this._lastPos, i);\n      } else {\n        // Parsing value\n\n        i = skipValBytes(this, chunk, i, len);\n        while (i < len) {\n          switch (chunk[i]) {\n            case 38:\n              // '&'\n              if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = ++i;\n              this._inKey = true;\n              this._val = this._decoder(this._val, this._encode);\n              this._encode = 0;\n              if (this._bytesKey > 0 || this._bytesVal > 0) {\n                this.emit('field', this._key, this._val, {\n                  nameTruncated: this._keyTrunc,\n                  valueTruncated: this._valTrunc,\n                  encoding: this.charset,\n                  mimeType: 'text/plain'\n                });\n              }\n              this._key = '';\n              this._val = '';\n              this._keyTrunc = false;\n              this._valTrunc = false;\n              this._bytesKey = 0;\n              this._bytesVal = 0;\n              if (++this._fields >= this.fieldsLimit) {\n                this.emit('fieldsLimit');\n                return cb();\n              }\n              continue main;\n            case 43:\n              // '+'\n              if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);\n              this._val += ' ';\n              this._lastPos = i + 1;\n              break;\n            case 37:\n              // '%'\n              if (this._encode === 0) this._encode = 1;\n              if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);\n              this._lastPos = i + 1;\n              this._byte = -1;\n              i = readPctEnc(this, chunk, i + 1, len);\n              if (i === -1) return cb(new Error('Malformed urlencoded form'));\n              if (i >= len) return cb();\n              ++this._bytesVal;\n              i = skipValBytes(this, chunk, i, len);\n              continue;\n          }\n          ++i;\n          ++this._bytesVal;\n          i = skipValBytes(this, chunk, i, len);\n        }\n        if (this._lastPos < i) this._val += chunk.latin1Slice(this._lastPos, i);\n      }\n    }\n    cb();\n  }\n  _final(cb) {\n    if (this._byte !== -2) return cb(new Error('Malformed urlencoded form'));\n    if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {\n      if (this._inKey) this._key = this._decoder(this._key, this._encode);else this._val = this._decoder(this._val, this._encode);\n      this.emit('field', this._key, this._val, {\n        nameTruncated: this._keyTrunc,\n        valueTruncated: this._valTrunc,\n        encoding: this.charset,\n        mimeType: 'text/plain'\n      });\n    }\n    cb();\n  }\n}\nfunction readPctEnc(self, chunk, pos, len) {\n  if (pos >= len) return len;\n  if (self._byte === -1) {\n    // We saw a '%' but no hex characters yet\n    const hexUpper = HEX_VALUES[chunk[pos++]];\n    if (hexUpper === -1) return -1;\n    if (hexUpper >= 8) self._encode = 2; // Indicate high bits detected\n\n    if (pos < len) {\n      // Both hex characters are in this chunk\n      const hexLower = HEX_VALUES[chunk[pos++]];\n      if (hexLower === -1) return -1;\n      if (self._inKey) self._key += String.fromCharCode((hexUpper << 4) + hexLower);else self._val += String.fromCharCode((hexUpper << 4) + hexLower);\n      self._byte = -2;\n      self._lastPos = pos;\n    } else {\n      // Only one hex character was available in this chunk\n      self._byte = hexUpper;\n    }\n  } else {\n    // We saw only one hex character so far\n    const hexLower = HEX_VALUES[chunk[pos++]];\n    if (hexLower === -1) return -1;\n    if (self._inKey) self._key += String.fromCharCode((self._byte << 4) + hexLower);else self._val += String.fromCharCode((self._byte << 4) + hexLower);\n    self._byte = -2;\n    self._lastPos = pos;\n  }\n  return pos;\n}\nfunction skipKeyBytes(self, chunk, pos, len) {\n  // Skip bytes if we've truncated\n  if (self._bytesKey > self.fieldNameSizeLimit) {\n    if (!self._keyTrunc) {\n      if (self._lastPos < pos) self._key += chunk.latin1Slice(self._lastPos, pos - 1);\n    }\n    self._keyTrunc = true;\n    for (; pos < len; ++pos) {\n      const code = chunk[pos];\n      if (code === 61 /* '=' */ || code === 38 /* '&' */) break;\n      ++self._bytesKey;\n    }\n    self._lastPos = pos;\n  }\n  return pos;\n}\nfunction skipValBytes(self, chunk, pos, len) {\n  // Skip bytes if we've truncated\n  if (self._bytesVal > self.fieldSizeLimit) {\n    if (!self._valTrunc) {\n      if (self._lastPos < pos) self._val += chunk.latin1Slice(self._lastPos, pos - 1);\n    }\n    self._valTrunc = true;\n    for (; pos < len; ++pos) {\n      if (chunk[pos] === 38 /* '&' */) break;\n      ++self._bytesVal;\n    }\n    self._lastPos = pos;\n  }\n  return pos;\n}\n\n/* eslint-disable no-multi-spaces */\nconst HEX_VALUES = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];\n/* eslint-enable no-multi-spaces */\n\nmodule.exports = URLEncoded;","map":null,"metadata":{},"sourceType":"script"}